from collections import deque

# State: (M_left, C_left, Boat_side)
# Boat_side = 1 means boat is on left, 0 means on right
# Initially: (3,3,1), Goal: (0,0,0)

def is_valid(state):
    M_left, C_left, boat = state
    M_right = 3 - M_left
    C_right = 3 - C_left

    # Missionaries >= 0 and Cannibals >= 0
    if M_left < 0 or C_left < 0 or M_right < 0 or C_right < 0:
        return False

    # If missionaries present, they should not be outnumbered
    if (M_left > 0 and M_left < C_left) or (M_right > 0 and M_right < C_right):
        return False

    return True

def get_successors(state):
    M_left, C_left, boat = state
    successors = []
    moves = [(1,0), (2,0), (0,1), (0,2), (1,1)]  # possible passengers

    for m, c in moves:
        if boat == 1:  # Boat on left → move people to right
            new_state = (M_left - m, C_left - c, 0)
        else:          # Boat on right → move people to left
            new_state = (M_left + m, C_left + c, 1)

        if is_valid(new_state):
            successors.append(new_state)

    return successors

def bfs(start, goal):
    q = deque([(start, [start])])  # (state, path)
    visited = set([start])

    while q:
        state, path = q.popleft()

        if state == goal:
            return path

        for succ in get_successors(state):
            if succ not in visited:
                visited.add(succ)
                q.append((succ, path + [succ]))

    return None

# Driver code
if __name__ == "__main__":
    start = (3, 3, 1)   # 3 missionaries, 3 cannibals, boat on left
    goal = (0, 0, 0)    # all on right
    solution = bfs(start, goal)

    if solution:
        print("Solution found!")
        for step in solution:
            print(step)
    else:
        print("No solution exists.")
