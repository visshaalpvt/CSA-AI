import heapq

# 8-Puzzle solver using A* with Manhattan distance heuristic

class PuzzleState:
    def __init__(self, board, parent=None, move="", depth=0, cost=0):
        self.board = board
        self.parent = parent
        self.move = move
        self.depth = depth
        self.cost = cost
        self.blank = self.board.index(0)  # 0 represents the blank space

    def __lt__(self, other):
        return (self.cost + self.depth) < (other.cost + other.depth)

    def generate_children(self):
        children = []
        x, y = divmod(self.blank, 3)
        moves = {
            "Up": (x - 1, y),
            "Down": (x + 1, y),
            "Left": (x, y - 1),
            "Right": (x, y + 1)
        }

        for move, (nx, ny) in moves.items():
            if 0 <= nx < 3 and 0 <= ny < 3:
                new_blank = nx * 3 + ny
                new_board = self.board[:]
                new_board[self.blank], new_board[new_blank] = new_board[new_blank], new_board[self.blank]
                children.append(PuzzleState(new_board, self, move, self.depth + 1, 0))
        return children

def manhattan_distance(board, goal):
    distance = 0
    for i, tile in enumerate(board):
        if tile != 0:
            goal_index = goal.index(tile)
            x1, y1 = divmod(i, 3)
            x2, y2 = divmod(goal_index, 3)
            distance += abs(x1 - x2) + abs(y1 - y2)
    return distance

def a_star(start, goal):
    open_list = []
    closed_set = set()

    start_state = PuzzleState(start, None, "", 0, manhattan_distance(start, goal))
    heapq.heappush(open_list, start_state)

    while open_list:
        current = heapq.heappop(open_list)

        if current.board == goal:
            return current

        closed_set.add(tuple(current.board))

        for child in current.generate_children():
            if tuple(child.board) not in closed_set:
                child.cost = manhattan_distance(child.board, goal)
                heapq.heappush(open_list, child)

    return None

def print_solution(solution):
    path = []
    while solution:
        path.append(solution)
        solution = solution.parent

    path.reverse()
    for state in path:
        print("Move:", state.move)
        for i in range(0, 9, 3):
            print(state.board[i:i+3])
        print()

# Example usage
if __name__ == "__main__":
    start = [1, 2, 3,
             4, 0, 6,
             7, 5, 8]   # 0 is the blank

    goal = [1, 2, 3,
            4, 5, 6,
            7, 8, 0]

    solution = a_star(start, goal)
    if solution:
        print("Solution found!")
        print_solution(solution)
    else:
        print("No solution exists.")
